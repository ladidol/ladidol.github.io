<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Docker入门 | 小小的博客乐园</title><meta name="keywords" content="Docker,入门"><meta name="author" content="ladidol"><meta name="copyright" content="ladidol"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言:1.前提知识: springboot,springclouds,git push pull,redis nginx mysqllinux centos ubuntu  Docker 一篇入门这里有阮一峰老师的docker简介传送门 这里有个语雀大佬的笔记传送门 后序也可以参考这个文章 一、Docker 简介1、基本概述Docker是世界领先的软件容器平台。 Docker是基于Go语言实现的云">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker入门">
<meta property="og:url" content="http://ladfeng.top/2022/03/21/Docker%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="小小的博客乐园">
<meta property="og:description" content="前言:1.前提知识: springboot,springclouds,git push pull,redis nginx mysqllinux centos ubuntu  Docker 一篇入门这里有阮一峰老师的docker简介传送门 这里有个语雀大佬的笔记传送门 后序也可以参考这个文章 一、Docker 简介1、基本概述Docker是世界领先的软件容器平台。 Docker是基于Go语言实现的云">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.ladidol.top/img/wallhaven-z8m6gj.jpg">
<meta property="article:published_time" content="2022-03-21T14:05:23.000Z">
<meta property="article:modified_time" content="2022-04-16T12:33:09.308Z">
<meta property="article:author" content="ladidol">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="入门">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.ladidol.top/img/wallhaven-z8m6gj.jpg"><link rel="shortcut icon" href="https://qiniu.ladidol.top/img/favicon.png"><link rel="canonical" href="http://ladfeng.top/2022/03/21/Docker%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-16 20:33:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><meta name="generator" content="Hexo 6.1.0"></head><body>
    
<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://qiniu.ladidol.top/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-diamond"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/sport/"><i class="fa-fw fa fa-paper-plane"></i><span> 运动记录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://qiniu.ladidol.top/img/wallhaven-z8m6gj.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小小的博客乐园</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-diamond"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/sport/"><i class="fa-fw fa fa-paper-plane"></i><span> 运动记录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-21T14:05:23.000Z" title="发表于 2022-03-21 22:05:23">2022-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-16T12:33:09.308Z" title="更新于 2022-04-16 20:33:09">2022-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/docker/">docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p><strong>1.前提知识:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">springboot,springclouds,</span><br><span class="line">git push pull,</span><br><span class="line">redis </span><br><span class="line">nginx </span><br><span class="line">mysql</span><br><span class="line">linux centos ubuntu</span><br></pre></td></tr></table></figure>

<h2 id="Docker-一篇入门"><a href="#Docker-一篇入门" class="headerlink" title="Docker 一篇入门"></a>Docker 一篇入门</h2><p>这里有阮一峰老师的docker简介<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">传送门</a></p>
<p>这里有个语雀大佬的笔记<a target="_blank" rel="noopener" href="https://www.yuque.com/mrlinxi/pxvr4g/polyyw">传送门</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YlcvlUQ-xkz25PuYkeEQqw">后序也可以参考这个文章</a></p>
<h2 id="一、Docker-简介"><a href="#一、Docker-简介" class="headerlink" title="一、Docker 简介"></a>一、Docker 简介</h2><h3 id="1、基本概述"><a href="#1、基本概述" class="headerlink" title="1、基本概述"></a>1、基本概述</h3><p>Docker是世界领先的软件容器平台。</p>
<p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“<strong>Build，Ship and Run Any App,Anywhere</strong>”。</p>
<p>通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<strong>“一次封装，到处运行”</strong>。</p>
<p>因为虚拟机模拟的就是带操作系统和环境的，其资源占用多、冗余步骤多、启动慢等不足，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
<p>Docker 在Linux 容器技术的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到不同的机器上就可以一键部署好，大大简化了操作。这样是顺应了 DevOps 开发运维理念。</p>
<p>针对集群环境，可以快速部署安装。</p>
<p>Docker是不携带操作系统的，所有Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等这些资源的时候，拿内存举例，虚拟机时利用Htpervisor去虚拟化内存，整个调用过程时<strong>虚拟化内存-&gt;虚拟物理内存-&gt;真正物理内存</strong>,但是Docker是利用Docker Engine去调用宿主机的资源，这个过程是<strong>虚拟内存-&gt;物理内存</strong>。</p>
<h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1、环境检查"><a href="#1、环境检查" class="headerlink" title="1、环境检查"></a>1、环境检查</h3><p>CentOS Docker 安装<br>Docker支持以下的CentOS版本：<br>CentOS 7 (64-bit)<br>CentOS 6.5 (64-bit) 或更高的版本</p>
<p>前提条件<br>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p>
<p>Linux 检查内核版本命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>笔者的服务器linux内核版本为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux version 3.10.0-1160.11.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Fri Dec 18 16:34:56 UTC 2020</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZ2vc5bu6hb90ck1lw0pdtZ ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version:	:core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID:	CentOS</span><br><span class="line">Description:	CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">Release:	7.9.2009</span><br><span class="line">Codename:	Core</span><br></pre></td></tr></table></figure>

<p>如果命令 <code>lsb_release -a</code>提示<code>command not found</code>则需要安装<code>yum install redhat-lsb -y</code>。</p>
<h3 id="2、基本组成"><a href="#2、基本组成" class="headerlink" title="2、基本组成"></a>2、基本组成</h3><p>docker主机(Host)：安装了Docker程序的机器，Docker直接安装在操作系统（windows &#x2F; linux）上；<br>docker客户端(Client)：连接docker主机进行操作；<br><strong>docker仓库(Registry)：</strong>用来保存各种打包好的软件镜像；<br><strong>docker镜像(Images)：</strong>软件打包好的镜像；放在docker仓库中；<br><strong>docker容器(Container)：</strong>镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用。</p>
<p>架构图：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/docketVSvmware.jpg" alt="img"></h3><h3 id="3、安装步骤"><a href="#3、安装步骤" class="headerlink" title="3、安装步骤"></a>3、安装步骤</h3><p>官方文档也有安装步骤：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
<p><strong>Centos 6.8 安装Docker：</strong></p>
<p>（1）环境准备</p>
<p>Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>

<p>（2）安装docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-io</span><br></pre></td></tr></table></figure>

<p>（3）配置文件</p>
<p>安装后的配置文件：&#x2F;etc&#x2F;sysconfig&#x2F;docker</p>
<p>（4）启停操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service docker start</span><br><span class="line">service docker stop</span><br></pre></td></tr></table></figure>

<p>（5）验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><strong>Centos 7 安装Docker：</strong></p>
<p>（1）环境检查</p>
<p>版本确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br></pre></td></tr></table></figure>

<p>联网检查</p>
<p>（2）gcc环境安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p>（3）旧版卸载</p>
<p>可参考官网操作，新机器可省略此操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>（4）安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>（5）修改镜像仓库</p>
<p>主要是为了优化下载速度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>（6）更新yum包索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>（7）安装Docker CE</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>

<p>（8）启停操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>（9）测试验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>（10）配置镜像加速</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">systemctl daemon-reload  <span class="comment"># 重新加载</span></span><br><span class="line">systemctl restart docker <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>

<p><code>daemon.json</code> 内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#网易云</span><br><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;] &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"> #阿里云</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://｛自已的编码｝.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不注册就是用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（11）卸载docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">yum -y remove docker-ce</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<p>关于阿里云或网易云镜像加速</p>
<p>注册阿里云账户，登录阿里云开发者平台，获取加速器地址，配置参考第（10）步。</p>
<p>（12）更多命令</p>
<p> （A） ：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/docker/">Docker 官方文档</a></p>
<p> （B）：参考每一个镜像的文档。</p>
<h3 id="4-测试运行hello-world"><a href="#4-测试运行hello-world" class="headerlink" title="4.测试运行hello-world"></a>4.测试运行hello-world</h3><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323171124370.png" alt="image-20220323171124370"></p>
<p>run干了什么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638188169013-68f7d053-b6a9-4795-ae3a-e61f4a38deae.png" alt="image.png"></p>
<h2 id="三、Docker-原理"><a href="#三、Docker-原理" class="headerlink" title="三、Docker 原理"></a>三、Docker 原理</h2><p>整体架构及底层通信原理简述:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330113100331.png" alt="image-20220330113100331"></p>
<p>结构图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330113159195.png" alt="image-20220330113159195"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330113308771.png" alt="image-20220330113308771"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330113441702.png" alt="image-20220330113441702"></p>
<h3 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的"></a>docker是怎么工作的</h3><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22423156/1638188268502-e7e8cdf3-cc93-446f-a18a-7a827d2dd55c.png" alt="image.png"></p>
<h3 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h3><p>(1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<p>(2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p>
<p>docker和vm的对比表:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323171737029.png" alt="image-20220323171737029"></p>
<h2 id="四、Docker常用命令"><a href="#四、Docker常用命令" class="headerlink" title="四、Docker常用命令"></a>四、Docker常用命令</h2><h3 id="4-1帮助启动类命令"><a href="#4-1帮助启动类命令" class="headerlink" title="4.1帮助启动类命令"></a>4.1帮助启动类命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker #启动docker</span><br><span class="line">systemctl stop docker #停止</span><br><span class="line">systemctl restart docker #重启</span><br><span class="line">systemctl status docker #查看状态</span><br><span class="line">docker version：详细版本信息    </span><br><span class="line">docker -v：简略版本信息</span><br><span class="line">docker info：对docker镜像、容器、宿主机情况等描述</span><br><span class="line">docker --help：类似于Linux的man，列举所有命令及其含义解释。</span><br><span class="line">docker [command命令] --help #查看某个命令的用法</span><br><span class="line">dockerd --debug: 可以找到为什么docker启动不了的原因</span><br></pre></td></tr></table></figure>

<h3 id="4-2-镜像命令"><a href="#4-2-镜像命令" class="headerlink" title="4.2 镜像命令"></a>4.2 镜像命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [ARGS]：列出本地主机上的镜像</span><br><span class="line">OPTIONS说明：可以通过docker iamges --<span class="built_in">help</span>查看OPTIONS</span><br><span class="line">● -a ：a表示all，列出本地所有的镜像（含中间映像层）</span><br><span class="line">● -q ：只显示镜像ID。</span><br><span class="line">● --digests ：显示镜像的摘要信息</span><br><span class="line">● --no-trunc：:显示完整的镜像信息</span><br><span class="line">ARGS说明：可以直接写镜像名，比如centos，mysql等等，就是直接查对应的镜像信息。</span><br><span class="line"></span><br><span class="line">docker search [OPTIONS] 某个个xxx镜像名字：查镜像</span><br><span class="line">OPTIONS说明： 可以通过docker search --<span class="built_in">help</span>查看OPTIONS</span><br><span class="line">● --no-trunc : 显示完整的镜像描述</span><br><span class="line">● --<span class="built_in">limit</span> int : 显示最多int条信息。</span><br><span class="line"></span><br><span class="line">docker pull 某个个xxx镜像名字[:TAG]：下载镜像</span><br><span class="line">不写版本号默认下载最新版</span><br><span class="line"></span><br><span class="line">docker rmi 某个个xxx镜像ID：删除镜像</span><br></pre></td></tr></table></figure>

<p>我们尝试删除一下hello-world</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZ2vc5bu6hb90ck1lw0pdtZ ~]<span class="comment"># docker rmi feb5d9fea6a5</span></span><br><span class="line">Error response from daemon: conflict: unable to delete feb5d9fea6a5 (must be forced) - image is being used by stopped container 4cb79a86d213</span><br><span class="line">[root@iZ2vc5bu6hb90ck1lw0pdtZ ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>报错了，因为我们正在使用hello-world需要加-f强制删除<code>docker rmi -f hello-world</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● 删除单个：docker rmi -f 镜像ID/镜像名[:TAG]</span><br><span class="line">● 删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br><span class="line">● 删除全部：docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZ2vc5bu6hb90ck1lw0pdtZ ~]<span class="comment"># docker rmi -f feb5d9fea6a5</span></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:bfea6278a0a267fad2634554f4f0c6f31981eea41c553fdf5a83e95a41d40c38</span><br><span class="line">Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</span><br></pre></td></tr></table></figure>

<h3 id="4-3容器命令"><a href="#4-3容器命令" class="headerlink" title="4.3容器命令"></a>4.3容器命令</h3><h4 id="1下载镜像，新建并启动容器"><a href="#1下载镜像，新建并启动容器" class="headerlink" title="1下载镜像，新建并启动容器"></a>1<strong>下载镜像，新建并启动容器</strong></h4><p>有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示) <code>docker pull centos</code></p>
<p>一个小插曲：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error response from daemon: pull access denied for centors, repository does not exist or may require &#x27;docker login&#x27;: denied: requested access to the resource is denied</span><br></pre></td></tr></table></figure>

<p>这是docker pull centos写错了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323173645773.png" alt="image-20220323173645773"></p>
<p>我们继续。。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323173752024.png" alt="image-20220323173752024"></p>
<p>一个centos只有231M。<br>新建并启动容器，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [options] imageID/imageName[:TAG] [<span class="built_in">command</span>] [arg..]</span><br><span class="line">options说明：</span><br><span class="line">●--name=<span class="string">&quot;容器新名字&quot;</span>: 为容器指定一个名称；</span><br><span class="line">●-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line">●-i：<span class="string">&quot;以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line"><span class="string">●-t：&quot;</span>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">●-P: 随机端口映射；</span><br><span class="line">●-p: 指定端口映射，有以下四种格式</span><br><span class="line">○ip:hostPort:containerPort</span><br><span class="line">○ip::containerPort</span><br><span class="line">○<span class="string">&quot;hostPort:containerPort</span></span><br><span class="line"><span class="string">○containerPort</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323174025226.png" alt="image-20220323174025226"></p>
<p>现在我们进入了，centos容器。（-i -t可以合在一起写成-it）</p>
<h4 id="2列出当前所有正在运行的容器"><a href="#2列出当前所有正在运行的容器" class="headerlink" title="2列出当前所有正在运行的容器"></a>2<strong>列出当前所有正在运行的容器</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">●-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">●-l :显示最近创建的容器。</span><br><span class="line">●-n：显示最近n个创建的容器。</span><br><span class="line">●-q :静默模式，只显示容器编号。</span><br><span class="line">●--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure>

<p>在刚刚centos容器启动的情况下新打开一个终端窗口<br><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323174522574.png" alt="image-20220323174522574"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323174510415.png" alt="image-20220323174510415"></p>
<p>可以看到正在运行的容器ID，跟我们启动的centos容器一致。这表示我们通过docker在centos上运行了一个centos容器。</p>
<h4 id="3退出容器"><a href="#3退出容器" class="headerlink" title="3退出容器"></a>3退出容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入<span class="built_in">exit</span>：容器<span class="string">&quot;停止退出；</span></span><br><span class="line"><span class="string">ctrl+d：容器&quot;</span>停止退出</span><br><span class="line"></span><br><span class="line">ctrl+P+Q：容器<span class="string">&quot;不停止退出</span></span><br></pre></td></tr></table></figure>

<p>先exit退出我们运行的centos容器实例。然后，我们以centosByDocker为名字，生成一个centos的容器实例：</p>
<p><code>docker run -it --name centosByDocker centos</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323175241367.png" alt="image-20220323175241367"></p>
<p>然后按ctrl+P+Q，（按了之后还要按一下回车）回到我们的宿主机：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323175353435.png" alt="image-20220323175353435"></p>
<p>然后执行<code>docker ps</code>可以看到容器<strong>没有关闭</strong>。说明都没有停止再退出容器</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323175541956.png" alt="image-20220323175541956"></p>
<h4 id="4启动容器（start-与-run区分开）-amp-重启容器（restart）"><a href="#4启动容器（start-与-run区分开）-amp-重启容器（restart）" class="headerlink" title="4启动容器（start 与 run区分开） &amp; 重启容器（restart）"></a>4<strong>启动容器（start 与 run区分开） &amp; 重启容器（restart）</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start是启动已有容器，docker run是新建并启动容器，这里需要区分开。</span><br><span class="line">启动容器：docker start 容器ID/容器Names即可启动容器。</span><br><span class="line">重启容器：docker restart 容器ID/容器Names</span><br></pre></td></tr></table></figure>

<p>这些好像都能不能进去</p>
<h4 id="5回到已经退出的但是仍然在运行的容器"><a href="#5回到已经退出的但是仍然在运行的容器" class="headerlink" title="5回到已经退出的但是仍然在运行的容器"></a>5回到已经退出的但是仍然在运行的容器</h4><p><code>docker attach 容器ID、容器Names</code>能重新进到正在运行的容器中</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323180948856.png" alt="image-20220323180948856"></p>
<p><code>docker exec -it 容器ID bashShell</code></p>
<p>这个命令不同于上面的命令，进入到了指定id的容器内部并将【bashshell命令】执行结果返回到宿主机上</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323181244914.png" alt="image-20220323181244914"></p>
<p><code>nsenter</code>命令[传送门](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式 - 純黑色 - 博客园 (cnblogs.com)</a>)</p>
<h4 id="6停止容器-amp-强制停止容器"><a href="#6停止容器-amp-强制停止容器" class="headerlink" title="6停止容器 &amp; 强制停止容器"></a><strong>6停止容器 &amp; 强制停止容器</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">停止容器：`docker stop 容器ID/容器name`</span><br><span class="line">强制停止容器：`docker kill 容器ID/容器name`</span><br></pre></td></tr></table></figure>

<p>停止容器</p>
<h4 id="7删除已停止的容器"><a href="#7删除已停止的容器" class="headerlink" title="7删除已停止的容器"></a><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323180047806.png" alt="image-20220323180047806">7删除已停止的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID：删除之前需要停止容器。</span><br><span class="line">docker rm -f 容器ID：强制删除，容器运行时可以直接删除。</span><br><span class="line">一次性删除多个容器：</span><br><span class="line">●docker rm -f $(docker ps -a -q)</span><br><span class="line">●docker ps -a -q | xargs docker rm</span><br><span class="line">●docker rm 容器ID1 容器ID2 ..</span><br></pre></td></tr></table></figure>

<p><font color='red'> 注：删除的时候不需要吧容器ID写全，写两位就可以，删除前请核对，防止误删。 </font></p>
<h4 id="8重要容器命令"><a href="#8重要容器命令" class="headerlink" title="8重要容器命令"></a>8重要容器命令</h4><p><strong>1. 启动守护式容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令：docker run -d 镜像名[:TAG]/镜像ID</span><br><span class="line">（后台启动）启动守护容器centos：docker run -d --name centosde centos</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323182922704.png" alt="image-20220323182922704"></p>
<p><strong>问题：</strong>然后docker ps进行查看, 会发现容器已经退出，并没有处于运行状态。</p>
<p>如果在运行的话，会发现，其实已经运行于后台了,应该可以通过docker ps -a显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323182956301.png" alt="image-20220323182956301"></p>
<p><strong>很重要的要说明的一点:</strong> </p>
<p>Docker容器后台运行，就必须有一个前台进程。</p>
<p>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。<br>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动相应的service即可。例如service nginx start但是,这样做，nginx为后台进程模式运行，就导致docker前台没有运行的应用,，这样的容器后台启动后,会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行。</p>
<p><strong>2. 查看容器日志</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令：docker logs -f -t --tail 数字 容器ID </span><br><span class="line">●-t：表示加入时间戳</span><br><span class="line">●-f：表示跟随最新的日志打印</span><br><span class="line">●--tail 数字：表示显示最后多少条</span><br></pre></td></tr></table></figure>

<p>后台运行centos，循环打印一句话：<code>docker run -d centos /bin/sh -c &quot;while true;do echo hello ladidol world;sleep 2;done&quot;</code></p>
<p>这个能显示到docker ps中我是没想到的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323185149116.png" alt="image-20220323185149116"></p>
<p>查询一下容器日志：<code>docker logs -f -t --tail 10 容器ID/容器NAME</code></p>
<p>这里加了-f会不停的追加，如果不加就只会打印–tail指定数目的记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323185342763.png" alt="image-20220323185342763"></p>
<p>ctrl+ z 推出查看容器日志</p>
<p><strong>3. 查看容器内的进程 &amp; 查看容器内部细节</strong><br>查看容器内进程命令：<code>docker top 容器ID/容器名</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323185721124.png" alt="image-20220323185721124"></p>
<p><strong>4. 进入正在运行的容器并以命令行交互</strong><br>docker run -it centos 创建并启动一个centos容器，然后ctrl+p+q退出容器但不关闭。<br>那么如何再次进入这个容器呢？<br>●使用<code>docker attach </code>容器ID&#x2F;容器name命令即可再次进入容器。<br>●使用<code>docker exec -it </code>容器ID&#x2F;容器name &#x2F;bin&#x2F;bash</p>
<p>前面有讲到：</p>
<p><code>docker attach 容器ID、容器Names</code>能重新进到正在运行的容器中</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323180948856.png" alt="image-20220323180948856"></p>
<p><code>docker exec -it 容器ID bashShell</code></p>
<p>这个命令不同于上面的命令，进入到了指定id的容器内部并将【bashshell命令】执行结果返回到宿主机上</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323181244914.png" alt="image-20220323181244914"></p>
<p>exec与attach的区别：<br>attach 直接进入容器启动命令的终端，不会启动新的进程；<br>exec 是在容器中打开新的终端，并且可以启动新的进程；<br>通过exec进入的容器，使用exit退出时，容器不会关闭。</p>
<p><strong>关于-i -t 与 -it的区别：</strong>i是创建标准io接口，t是伪造tty终端；如果光一个i的话，虽然也可以输入命令得到输出，但结果很不友好，自己可以试试；如果光一个t，就只有一个tty，你输入什么都没有反应，因为你没有开放对应的输入接口；正确的应该是-it，开放接口并创建伪tty。</p>
<p><strong>5. 从容器内拷贝文件到主机上</strong><br>命令：<code>docker cp </code> 容器ID:容器内路径 目的主机路径</p>
<h3 id="4-3总结"><a href="#4-3总结" class="headerlink" title="4.3总结"></a>4.3总结</h3><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638248364830-ec5bca6d-ba97-4138-adb0-e5e0800b1a40.png" alt="image.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化</span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line">images    List images                                   # 列出系统当前镜像</span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容</span><br></pre></td></tr></table></figure>

<h2 id="五、Dockers镜像"><a href="#五、Dockers镜像" class="headerlink" title="五、Dockers镜像"></a>五、Dockers镜像</h2><h3 id="5-1-镜像是什么-amp-镜像的特点"><a href="#5-1-镜像是什么-amp-镜像的特点" class="headerlink" title="5.1 镜像是什么 &amp; 镜像的特点"></a>5.1 镜像是什么 &amp; 镜像的特点</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p> <strong>1. UnionFS（联合文件系统）</strong> </p>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p> <strong>2.  Docker镜像加载原理</strong> </p>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统称为UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638248743091-a2137397-2cc7-42ed-9625-dc30893165ca.png" alt="image.png"></p>
<p>思考：平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？<br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<p><strong>3. 镜像分层</strong><br>我们在pull镜像的时候，可以看到docker的镜像好像是一层一层的在下载。<br>拿tomcat为例，一个单独的tomcat一般只有100多M，但是docker拉取的镜像有400多M，这是为什么？<br>因为tomcat的运行不仅仅只需要tomcat，还需要java、centos等等依赖，所以docker的tomcat镜像中会包含有java、centos等等，所以会很大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638249258111-da897ffa-ddbd-4d28-b025-c5a090f6f4bb.png" alt="image.png"></p>
<p><strong>为什么镜像要采用这种分层结构？</strong><br>最大的一个好处就是 <strong>- 共享资源。</strong><br>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p><strong>4.镜像的特点</strong></p>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h3 id="5-2-Docker镜像commit操作补充"><a href="#5-2-Docker镜像commit操作补充" class="headerlink" title="5.2 Docker镜像commit操作补充"></a><strong>5.2 Docker镜像commit操作补充</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像</span><br><span class="line">docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p> <strong>案例演示</strong><br> <strong>① 拉取tomcat镜像并运行</strong><br>从Hub上下载tomcat镜像到本地并成功运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里将host的8888端口映射到容器的8080端口</span></span><br><span class="line">docker run -it -p 8888:8080 tomcat</span><br></pre></td></tr></table></figure>

<p> 我这里虚拟机没有GUI，所以需要通过windows的浏览器来访问tomcat，先看看防火墙是否开启以及是否开放了8888端口的访问权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8888/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>然后访问还是404。搜了一圈，解决办法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40891009/article/details/103898876">Docker方式启动tomcat,访问首页出现404错误</a><br>是因为docker的tomcat中&#x2F;usr&#x2F;local&#x2F;tomcat下的webapps文件夹是空的，而原本应该在webapps文件夹下的内容都在旁边的webapps.dist文件夹中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入正在运行的容器目录</span></span><br><span class="line">docer exec -it tomcat容器ID /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将webapps.dist命名为webapps即可，在此之前可以吧webapps重命名成别的名字</span></span><br><span class="line">mv webapps webapps2</span><br><span class="line">mv webapps.dist webapps</span><br></pre></td></tr></table></figure>

<p>访问成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638257655855-7f203155-75fd-48ec-8c66-969df3b1a8cb.png" alt="image.png"></p>
<p>退出（停止）tomcat：ctrl+c。</p>
<p>如果使用docker run -it -P tomcat命令：随机分配一个端口号，映射给8080</p>
<p> ② 使用commit提交我们修改过的tomcat<br><code>docker commit -m &quot;rename webapps.dist to webapps&quot; -a &quot;mrlinxi&quot; 85fc7f7c0182 mrlinxi/tomcat:0.1</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22423156/1638263596661-0b994177-b1fd-4d2f-8852-1d8808e8930d.png" alt="image.png"></p>
<p>新建并运行一个我们自己修改过的tomcat容器</p>
<p><code>docker run -it -p 3333:8080 mrlinxi/tomcat:0.1 </code>  注意版本号不要掉了不然docker会到仓库中找latest版本的mrlinxi&#x2F;tomcat，显然是找不到的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638272125196-1db0e1c9-e510-41bd-835b-2c0e03ada7ae.png" alt="image.png"></p>
<p>访问成功</p>
<p> ③ 后台运行-d </p>
<p><code>docker run -d -p 8888:8080 mrlinxi/tomcat:0.1 </code>  后台启动tomcat。</p>
<p>可以通过<code>docker attach 容器ID</code> 或者<code>docker exec -it 容器ID</code>进入交互页面。</p>
<h2 id="六、Docker容器数据卷"><a href="#六、Docker容器数据卷" class="headerlink" title="六、Docker容器数据卷"></a>六、Docker容器数据卷</h2><h3 id="6-1-容器数据卷简述"><a href="#6-1-容器数据卷简述" class="headerlink" title="6.1 容器数据卷简述"></a><strong>6.1 容器数据卷简述</strong></h3><p>先来看看Docker的理念：</p>
<p>●将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p>
<p>●容器之间希望有可能共享数据</p>
<p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。为了能保存数据在docker中我们使用卷。</p>
<p>一句话：有点类似我们Redis里面的rdb和aof文件。</p>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p>
<p>特点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1数据卷可在容器之间共享或重用数据</span><br><span class="line"></span><br><span class="line">2卷中的更改可以直接生效</span><br><span class="line"></span><br><span class="line">3数据卷中的更改不会包含在镜像的更新中</span><br><span class="line"></span><br><span class="line">4数据卷的生命周期一直持续到没有容器使用它为止</span><br><span class="line"></span><br><span class="line">5容器卷也可以完成主机到容器、容器到主机的数据共享（类似于 docker cp）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2-容器数据卷案例"><a href="#6-2-容器数据卷案例" class="headerlink" title="6.2 容器数据卷案例"></a>6.2 容器数据卷案例</h3><ol>
<li><h4 id="命令添加"><a href="#命令添加" class="headerlink" title="命令添加"></a>命令添加</h4></li>
</ol>
<p>命令：docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录  镜像名</p>
<p>添加之前：</p>
<p>前者为容器内，后者为宿主机；</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323200254912.png" alt="image-20220323200254912"></p>
<p>执行</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -v /myDataVolume:/dataVolumeContainer centos</span><br></pre></td></tr></table></figure>

<p>可以看到两边都生成了对应的文件夹：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323200831549.png" alt="image-20220323200831549"></p>
<p>备注：Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p>
<p>解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可</p>
<p>检查是否挂载成功：<code>docker inspect 容器ID</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323201328553.png" alt="image-20220323201328553"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323201339368.png" alt="image-20220323201339368"></p>
<p>已经成功了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638276849687-1d2ac968-80a4-4fc5-97f6-2610fac0d50e.png" alt="image.png">可以看到实现了宿主机跟容器之间的双向同步</p>
<p>② 容器停止退出后，主机修改后数据是否同步<br>容器先停止退出、主机修改host.txt、容器重启进入、查看主机修改过的host.log</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638277144504-440a8e3b-68a9-407b-82d2-5c17da524f0d.png" alt="image.png"></p>
<p><strong>③ 命令（带权限）</strong></p>
<p>带权限的命令：</p>
<p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code><br>ro表示read only只读。</p>
<p>执行：<code>docker run -it -v /myDataVolume:/dataVolumeContainer:ro centos</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638278104965-502de020-2f94-46c8-8a43-8fa5064de443.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638278136092-718bc608-09ad-4fd1-bdee-7d7cfa30b009.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638278242942-ba82d0ba-0b90-44f1-b339-5f67702ca552.png" alt="image.png"></p>
<ol start="2">
<li>DockerFile添加</li>
</ol>
<p>具体描述放到后面讲，这里先使用。</p>
<p><strong>主机根目录下新建mydocker文件夹并进入</strong>：<code>mkdir mydocker</code></p>
<p><strong>可在Dockerfile中使用</strong></p>
<p><strong>VOLUME指令来给镜像添加一个或多个数据卷</strong>：</p>
<p><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code></p>
<p><strong>说明</strong>：</p>
<p>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
<p><strong>File构建：</strong><br>创建一个文件Dockerfile，然后添加以下内容：<br><code>vim Dockerfile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">volume <span class="built_in">test</span></span></span><br><span class="line">FROM centos   </span><br><span class="line">VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323202205652.png" alt="image-20220323202205652"></p>
<p>build后生成镜像：获得一个新的镜像<br><code>docker build -f /mydocker/Dockerfile -t mrlinxi/centos .</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323202220708.png" alt="image-20220323202220708"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323202253780.png" alt="image-20220323202253780"></p>
<p>run我们设置好的容器：<br><code>docker run -it 27ffb21c539d /bin/bash</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220323202458563.png" alt="image-20220323202458563"></p>
<p>可以看到容器内已经创建好了卷地址。</p>
<p><strong>通过上述步骤，容器内的卷目录地址已经知道，对应的主机目录地址哪？？</strong></p>
<p>通过<code>docker inspect 容器ID</code>查看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638280759530-2b3ce964-ca52-49f4-a35b-3e3f99893544.png" alt="image.png"></p>
<h3 id="6-3-数据卷容器"><a href="#6-3-数据卷容器" class="headerlink" title="6.3 数据卷容器"></a>6.3 数据卷容器</h3><ol>
<li><strong>总体介绍</strong></li>
</ol>
<p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。实际上就是通过父容器传递数据卷的配置，通过传递数据卷的配置，将不同容器挂载到宿主机的相同目录下，从而实现各容器之间的数据传递。</p>
<p>以上一步新建的镜像mrlinxi&#x2F;centos为模板并运行容器dc01&#x2F;dc02&#x2F;dc03，他们已经具有容器卷&#x2F;dataVolumeContainer1和&#x2F;dataVolumeContainer2</p>
<ol start="2">
<li><strong>容器间传递共享(–volumes-from)</strong></li>
</ol>
<p>先启动一个父容器dc01，在dataVolumeContainer2中新增内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name dc01 mrlinxi/centos</span><br><span class="line">cd dataVolumeContainer2</span><br><span class="line">touch doc1.txt</span><br><span class="line"></span><br><span class="line">然后ctrl+p+q退出</span><br></pre></td></tr></table></figure>

<p>dc02&#x2F;dc03继承自dc01，通过–volumes-from继承<br><code>docker run -it --name dc02 --volumes-from dc01 mrlinxi/centos</code><br>然后在dc02和dc03的dataVolumeContainer2中分别添加各自的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 mrlinxi/centos</span><br><span class="line">cd dataVolumeContainer2</span><br><span class="line">touch doc2.txt</span><br><span class="line"></span><br><span class="line">docker run -it --name dc03 --volumes-from dc01 mrlinxi/centos</span><br><span class="line">cd dataVolumeContainer2</span><br><span class="line">touch doc3.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638325961173-0a0bfecb-ef9a-48ed-9753-5fb6d76c2ce2.png" alt="image.png"></p>
<p>回到dc01可以看到02&#x2F;03各自添加的都能共享了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638326029145-e9bbfb14-3537-4197-85ef-3fcec6f7a1d8.png" alt="image.png"></p>
<p>同理，dc02跟dc03里面都有其他容器的数据<img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638326179150-1b3890a3-61c0-4c35-aff9-a726cf11647f.png" alt="image.png"></p>
<p>删除dc01，dc02修改后dc03可否访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638326385031-9f225650-e7a4-45c3-bc8b-667c8a995f43.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638326404754-e815bf7c-19f5-422e-90b3-979e9d2ae71f.png" alt="image.png"></p>
<p>删除dc01后，dc02和dc03之间的数据共享并不受影响。</p>
<p><strong>结论</strong>：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p>
<h2 id="七-DockerFile解析"><a href="#七-DockerFile解析" class="headerlink" title="七. DockerFile解析"></a>七. DockerFile解析</h2><h3 id="7-1-DockerFile简介"><a href="#7-1-DockerFile简介" class="headerlink" title="7.1 DockerFile简介"></a>7.1 DockerFile简介</h3><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330123105447.png" alt="image-20220330123105447"></p>
<p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。<br>构建三步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">●编写Dockerfile文件：必须符合file规范</span><br><span class="line">●docker build：docker build -f /mydocker/Dockerfile -t mrlinxi/centos . 通过docker build获得一个自定义的镜像</span><br><span class="line">●docker run</span><br></pre></td></tr></table></figure>

<p>文件长什么样？下面就是我们使用的centos的Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> centos-7-x86_64-docker.tar.xz /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.schema-version=<span class="string">&quot;1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.name=<span class="string">&quot;CentOS Base Image&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.vendor=<span class="string">&quot;CentOS&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.license=<span class="string">&quot;GPLv2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.build-date=<span class="string">&quot;20201113&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.title=<span class="string">&quot;CentOS Base Image&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.vendor=<span class="string">&quot;CentOS&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.licenses=<span class="string">&quot;GPL-2.0-only&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.created=<span class="string">&quot;2020-11-13 00:00:00+00:00&quot;</span></span></span><br><span class="line"><span class="comment"># default cmd</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-DockerFile构建过程解析"><a href="#7-2-DockerFile构建过程解析" class="headerlink" title="7.2 DockerFile构建过程解析"></a>7.2 DockerFile构建过程解析</h3><p>Dockerfile内容基础知识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数</span><br><span class="line">- 指令按照从上到下，顺序执行</span><br><span class="line">- \#表示注释</span><br><span class="line">- 每条指令都会创建一个新的镜像层，并对镜像进行提交</span><br></pre></td></tr></table></figure>





<p>Docker执行Dockerfile的大致流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- （1）docker从基础镜像运行一个容器</span><br><span class="line">- （2）执行一条指令并对容器作出修改</span><br><span class="line">- （3）执行类似docker commit的操作提交一个新的镜像层</span><br><span class="line">- （4）docker再基于刚提交的镜像运行一个新容器</span><br><span class="line">- （5）执行dockerfile中的下一条指令直到所有指令都执行完成</span><br></pre></td></tr></table></figure>





<p>总结：</p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Dockerfile是软件的原材料</span><br><span class="line">- Docker镜像是软件的交付品</span><br><span class="line">- Docker容器则可以认为是软件的运行态。</span><br></pre></td></tr></table></figure>



<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638329841397-6503d73a-3107-4e68-85b5-5d2f690e19fb.png" alt="img"></p>
<ol>
<li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是<strong>文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程</strong>(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li>
<li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</li>
<li>Docker容器，容器是直接提供服务的。</li>
</ol>
<h3 id="7-3-DockerFile体系结构-保留字指令"><a href="#7-3-DockerFile体系结构-保留字指令" class="headerlink" title="7.3 DockerFile体系结构(保留字指令)"></a>7.3 DockerFile体系结构(保留字指令)</h3><p><strong>FROM</strong>：基础镜像，当前新镜像是基于哪个镜像的。基于什么镜像进行修改；<br><strong>MAINTAINER</strong>：镜像维护者的姓名和邮箱地址；<br><strong>RUN</strong>：容器构建时需要运行的命令；(docker build)<br><strong>EXPOSE</strong>：当前容器对外暴露出的端口；<br><strong>WORKDIR</strong>：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点，没写默认根目录<code>/</code>；<br><strong>ENV</strong>：用来在构建镜像过程中设置环境变量；<br>例如：<code>ENV MY_PATH /usr/mytest</code> 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量。<br>比如：<code>WORKDIR $MY_PATH</code><br><strong>ADD</strong>：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包；<br><strong>COPY</strong>：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置；  <code>COPY src dest</code>   <code>COPY [&quot;src&quot;, &quot;dest&quot;]</code><br><strong>ADD</strong>跟<strong>COPY</strong>的区别在于ADD在复制后会自动解压缩和处理URL，而COPY仅仅进行复制。<br><strong>VOLUME</strong>：容器数据卷，用于数据保存和持久化工作；<br><strong>CMD</strong>：指定一个容器启动时要运行的命令；Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换（后面案例会具体说明）；(docker run)<br><strong>ENTRYPOINT</strong>：指定一个容器启动时要运行的命令；ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数；<br><strong>CMD</strong>与<strong>ENTRYPOINT</strong>的区别是CMD存在多个时只有最后一个生效以及CMD会被docker run之后的参数替换；而ENTRYPOINT是追加命令。<br><strong>ONBUILD</strong>：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发<br><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638330806027-f7d631f5-99cd-4831-aea3-e9367ddf9d84.png" alt="img"></p>
<p>**entrypoint和cmd的用法实例:**包含cmd被覆盖对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330130137701.png" alt="image-20220330130137701"></p>
<p>主要指令结构:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/image-20220330130322239.png" alt="image-20220330130322239"></p>
<p>.gitlab-ci.yml文件中的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一些变量, 下面各阶段会使用</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">server_ip:</span> <span class="number">106.12</span><span class="number">.167</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">jar_name:</span> <span class="string">core-1.0-SNAPSHOT.jar</span></span><br><span class="line">  <span class="attr">java_path:</span> <span class="string">/usr/local/jdk/jdk1.8.0_321/bin</span></span><br><span class="line">  <span class="attr">TAG:</span> <span class="string">official-website:v1.0</span>  <span class="comment"># 镜像名称</span></span><br><span class="line">  <span class="attr">CONTAINER_NAME:</span> <span class="string">official-website-home</span></span><br><span class="line">  <span class="attr">PORT:</span> <span class="number">8999</span></span><br><span class="line">  <span class="attr">DOCKER_DRIVER:</span> <span class="string">overlay2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义执行的各个阶段及顺序</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 maven 镜像打包项目</span></span><br><span class="line"><span class="attr">maven-build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:3.5.0-jdk-8</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">package</span> <span class="string">-B</span> <span class="string">-Dmaven.test.skip=true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">m2-repo</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.m2/repository</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">core/target/$jar_name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build-master:</span> <span class="comment"># 定义的 Jobs 之一，用于构建 Docker 镜像。负责执行 deploy 这一流程。具体执行 build 和 run。</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">-f</span> <span class="string">$TAG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$TAG</span> <span class="string">.</span> <span class="comment"># 构件镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">$CONTAINER_NAME</span> <span class="string">||</span> <span class="literal">true</span> <span class="comment"># 删除容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">--restart=always</span> <span class="string">--name</span> <span class="string">$CONTAINER_NAME</span> <span class="string">--net=host</span> <span class="string">$TAG</span> <span class="comment"># 运行容器</span></span><br><span class="line">  <span class="attr">only:</span> <span class="comment"># 指定哪些branch的push commit会触发执行该job，本例子指定只有master才会执行deploy这个job</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这里是gitlab上面项目的dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/tmp&quot;</span>,<span class="string">&quot;/log&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./core/target/core-1.0-SNAPSHOT.jar core-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8999</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;-Xmx400m&quot;</span>,<span class="string">&quot;./core-1.0-SNAPSHOT.jar&quot;</span>,<span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure>





<h3 id="7-4-案例"><a href="#7-4-案例" class="headerlink" title="7.4 案例"></a>7.4 案例</h3><h4 id="1-Base镜像-scratch"><a href="#1-Base镜像-scratch" class="headerlink" title="1. Base镜像(scratch)"></a>1. Base镜像(scratch)</h4><p>Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。</p>
<h4 id="2-自定义镜像mycentos"><a href="#2-自定义镜像mycentos" class="headerlink" title="2. 自定义镜像mycentos"></a>2. 自定义镜像mycentos</h4><p>Hub默认CentOS镜像什么情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638339665774-80743dc3-bd3f-4781-bd49-68edecce815a.png" alt="img"></p>
<p>自定义mycentos目的使我们自己的镜像具备如下：</p>
<p>登陆后的默认路径、vim编辑器、查看网络配置ifconfig支持</p>
<p>① 编写自定义镜像的Dockerfile</p>
<p>我们在宿主机的<code>/mydocker</code>文件夹下，新建一个Dockerfile：<code>vim Dockerfile2</code>，写入下面的内容</p>
<p>这是.gitlab-ci.yml文件中的东西</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一些变量, 下面各阶段会使用</span></span><br><span class="line">variables:</span><br><span class="line">  server_ip: <span class="number">106.12</span>.<span class="number">167.1</span></span><br><span class="line">  jar_name: core-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line">  java_path: /usr/local/jdk/jdk1.<span class="number">8.0</span>_321/bin</span><br><span class="line">  TAG: official-website:v1.<span class="number">0</span>  <span class="comment"># 镜像名称</span></span><br><span class="line">  CONTAINER_NAME: official-website-home</span><br><span class="line">  PORT: <span class="number">8999</span></span><br><span class="line">  DOCKER_DRIVER: overlay2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义执行的各个阶段及顺序</span></span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 maven 镜像打包项目</span></span><br><span class="line">maven-build:</span><br><span class="line">  stage: build</span><br><span class="line">  image: maven:<span class="number">3.5</span>.<span class="number">0</span>-jdk-<span class="number">8</span></span><br><span class="line">  script:</span><br><span class="line">    - mvn package -B -Dmaven.test.skip=true</span><br><span class="line">  cache:</span><br><span class="line">    key: m2-repo</span><br><span class="line">    paths:</span><br><span class="line">      - .m2/repository</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - core/target/$jar_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build-master: <span class="comment"># 定义的 Jobs 之一，用于构建 Docker 镜像。负责执行 deploy 这一流程。具体执行 build 和 run。</span></span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - docker rmi -f $TAG</span><br><span class="line">    - docker build -t $TAG . <span class="comment"># 构件镜像</span></span><br><span class="line">    - docker rm -f $CONTAINER_NAME || true <span class="comment"># 删除容器</span></span><br><span class="line">    - docker <span class="keyword">run</span><span class="language-bash"> -d --restart=always --name <span class="variable">$CONTAINER_NAME</span> --net=host <span class="variable">$TAG</span> <span class="comment"># 运行容器</span></span></span><br><span class="line">  only: <span class="comment"># 指定哪些branch的push commit会触发执行该job，本例子指定只有master才会执行deploy这个job</span></span><br><span class="line">    - master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>② 构建自定义镜像——docker build</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f /mydocker/Dockerfile2 -t mycentos:0.1 .</span><br></pre></td></tr></table></figure>

<p>build语句最后面一个<code>.</code>表示当前目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638342897692-120c3467-e33e-45a7-b872-f384e5ea9e2d.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638342983932-5d1acdd1-4c9e-4181-b4ea-b7f569d245dc.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638342971620-02108df8-58de-4c01-b98b-fb160e364e7d.png" alt="img"></p>
<h4 id="③-运行自定义镜像——docker-run"><a href="#③-运行自定义镜像——docker-run" class="headerlink" title="③ 运行自定义镜像——docker run"></a>③ 运行自定义镜像——docker run</h4><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343174481-5f9a3806-9c45-4b0f-9dc2-463a9ebc1a23.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it mycentos:0.1</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343199833-59ddfef7-fdbf-4eb8-a0dd-15e3eb71572d.png" alt="img"></p>
<p>默认目录是&#x2F;usr&#x2F;locl，可以看到我们自己的新镜像已经支持vim&#x2F;ifconfig命令，拓展成功。</p>
<h4 id="④-列出镜像的变更历史"><a href="#④-列出镜像的变更历史" class="headerlink" title="④ 列出镜像的变更历史"></a>④ 列出镜像的变更历史</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343381128-8ce9fb4b-13ca-44ce-81a0-d33fcd71fd56.png" alt="img"></p>
<h4 id="3-CMD-x2F-ENTRYPOINT-镜像案例"><a href="#3-CMD-x2F-ENTRYPOINT-镜像案例" class="headerlink" title="3. CMD&#x2F;ENTRYPOINT 镜像案例"></a>3. CMD&#x2F;ENTRYPOINT 镜像案例</h4><p>CMD&#x2F;ENTRYPOINT都是指定一个容器启动时要运行的命令</p>
<h5 id="①-CMD镜像案例"><a href="#①-CMD镜像案例" class="headerlink" title="① CMD镜像案例"></a>① CMD镜像案例</h5><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换。</p>
<p>这里以tomcat为例，tomcat的dockerfile最后一句是</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343671342-f35165d2-de7f-4432-83da-c923ee3dff59.png" alt="img"></p>
<p>正常我们启动tomcat的命令是：<code>docker run -it -p 主机端口:8080 tomcat</code> </p>
<p>现在我们执行这样一句命令：<code>docker run -it -p 8888:8080 tomcat ls -l</code></p>
<p>这样就相当于在tomcat的dockerfile后面又加了一句<code>CMD ls -l</code>，因此会覆盖掉之前的语句。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343887509-4f0065c1-f5e1-46c5-9c20-df16d1955d1d.png" alt="img"></p>
<p>此时tomcat并没有运行，只是查看了默认路径下的文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638343953044-f74142c5-8327-4893-9634-e0fc4de40da7.png" alt="img"></p>
<h5 id="②-ENTRYPOINT镜像案例"><a href="#②-ENTRYPOINT镜像案例" class="headerlink" title="② ENTRYPOINT镜像案例"></a>② ENTRYPOINT镜像案例</h5><p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合。</p>
<p><strong>制作CMD版可以查询IP信息的容器：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;https://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>crul命令解释：curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。curl是将下载文件输出到stdout。</p>
<p>使用命令：curl <a target="_blank" rel="noopener" href="http://www.baidu.com,执行后,www.baidu.com的html就会显示在屏幕上了.这是最简单的使用方法.用这个命令获得了http//curl.haxx.se%E6%8C%87%E5%90%91%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%90%8C%E6%A0%B7%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E9%87%8C%E7%9A%84URL%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E4%B8%80%E5%B9%85%E5%9B%BE%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%98%AFHTML%E6%96%87%E6%A1%A3%EF%BC%8C%E9%82%A3%E4%B9%88%E7%BC%BA%E7%9C%81%E7%9A%84%E5%B0%86%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%8C%E5%8D%B3HTML%E6%96%87%E6%A1%A3%E7%9A%84header%E3%80%82%E8%A6%81%E5%85%A8%E9%83%A8%E6%98%BE%E7%A4%BA%EF%BC%8C%E8%AF%B7%E5%8A%A0%E5%8F%82%E6%95%B0">http://www.baidu.com，执行后，www.baidu.com的html就会显示在屏幕上了。这是最简单的使用方法。用这个命令获得了http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数</a> -i</p>
<p>构建镜像：<code>docker build -f /mydocker/Dockerfile3 -t myip .</code></p>
<p>创建并启动容器：<code>docker run myip</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638345202928-05625f38-4bba-48cb-b1a7-3b4f89b034ff.png" alt="img"></p>
<p>现在返回的是网页的html文件。</p>
<p><strong>如果我们希望显示 HTTP 头信息</strong>，就需要加上 <code>-i</code> 参数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638345312728-f6526519-cf9d-4471-a24e-02ac072f8bd1.png" alt="img"></p>
<p>加上<code>-i</code>后报错了。我们可以看到可执行文件找不到的报错，executable file not found。</p>
<p>之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a target="_blank" rel="noopener" href="https://ip.cn/">https://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run myip curl -s https://ip.cn -i</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638345446853-45d8a908-b0f9-4829-9dc4-26d36ff5642d.png" alt="img"></p>
<p>为了解决上述问题，<strong>制作ENTROYPOINT版查询IP信息的容器</strong>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br><span class="line">docker build -f /mydocker/Dockerfile4 -t myip2</span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> myip2 -i</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638345830872-e6ea7ad8-5414-4531-b40e-8ac0525ec186.png" alt="img"></p>
<p>现在只用追加一个<code>-i</code>即可打印请求头跟html文件。</p>
<h5 id="③-ONBUILD案例"><a href="#③-ONBUILD案例" class="headerlink" title="③ ONBUILD案例"></a>③ ONBUILD案例</h5><p>直接在Dockerfile4上修改，追加一句<code>ONBUILD RUN echo &quot;father onbuild-----------10086&quot;</code></p>
<p>然后使用Dockerfile4构建镜像：<code>docker build -f /mydocker/Dockerfile4 -t myip_father .</code></p>
<p>复制Dockerfile3命名为Dockerfile5，修改Dockerfile5，直接继承自Dockerfile4：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> myip_father</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;https://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>使用Dockerfile5构建镜像：<code>docker build -f /mydocker/Dockerfile5 -t myip_son .</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638346429961-5fa21a69-6fc1-4116-9153-5a772ed513d4.png" alt="img"></p>
<h3 id="7-5-自定义镜像Tomcat9"><a href="#7-5-自定义镜像Tomcat9" class="headerlink" title="7.5 自定义镜像Tomcat9"></a>7.5 自定义镜像Tomcat9</h3><h4 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="1. 创建目录"></a>1. 创建目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /mydocker/tomcat9</span><br></pre></td></tr></table></figure>

<p>在该目录下新建touch.txt文件</p>
<h4 id="2-将jdk和tomcat安装的压缩包拷贝进上述目录"><a href="#2-将jdk和tomcat安装的压缩包拷贝进上述目录" class="headerlink" title="2. 将jdk和tomcat安装的压缩包拷贝进上述目录"></a>2. 将jdk和tomcat安装的压缩包拷贝进上述目录</h4><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638349761007-70a682ef-bec4-47b8-afc1-a7f46998d9af.png" alt="img"></p>
<h4 id="3-在tomcat9目录下新建Dockerfile文件"><a href="#3-在tomcat9目录下新建Dockerfile文件" class="headerlink" title="3. 在tomcat9目录下新建Dockerfile文件"></a>3. 在tomcat9目录下新建Dockerfile文件</h4><p><strong>注意一下</strong>，Dockerfile文件里面涉及到<strong>jdk跟tomcat版本</strong>的地方<strong>一定要确定跟你放在tomcat9文件夹下的一致</strong>（别复制粘贴了就是build，到时候run运行不出来）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>         centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>    mrzhme&lt;mrzhme@vip.qq.com&gt;</span><br><span class="line"><span class="comment">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> c.txt /usr/local/cincontainer.txt</span></span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u301-linux-x64.tar.gz /usr/local/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.55.tar.gz /usr/local/</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_301</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">55</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">55</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="comment"># ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.55/bin/startup.sh&quot; ]</span></span><br><span class="line"><span class="comment"># CMD [&quot;/usr/local/apache-tomcat-9.0.55/bin/catalina.sh&quot;,&quot;run&quot;]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.55/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-9.0.55/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>

<h4 id="4-构建镜像：docker-build-t-mrlinxitomcat9"><a href="#4-构建镜像：docker-build-t-mrlinxitomcat9" class="headerlink" title="4. 构建镜像：docker build -t mrlinxitomcat9 ."></a>4. 构建镜像：<code>docker build -t mrlinxitomcat9 .</code></h4><p><strong>注意：</strong>这里为什么没有加 -f 和Dockerfile的路径？Dockerfile的标准文件名就是Dockerfile，当当前目录下用于构建镜像的Dockerfile的文件名是标准文件名时，可以省略-f+路径。这时Docker会直接读取当前目录下名为Dockerfile的文件进行镜像的构建。</p>
<h4 id="5-创建容器并启动"><a href="#5-创建容器并启动" class="headerlink" title="5. 创建容器并启动"></a>5. 创建容器并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8888:8080 --name myt9 -v /mydocker/tomcat9/test:/usr/local/apache-tomcat-9.0.55/webapps/test -v /mydocker/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.55/logs --privileged=true mrlinxitomcat9</span><br></pre></td></tr></table></figure>

<h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h4><p>记得防火墙开放对应的端口（直接关闭防火墙也可以，但是不推荐）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8888/tcp</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638356524487-9744cde1-e0f5-4dd6-bd3f-8bdc55c6249a.png" alt="img">访问成功。</p>
<h4 id="7-结合前述的容器卷将测试的web服务test发布"><a href="#7-结合前述的容器卷将测试的web服务test发布" class="headerlink" title="7. 结合前述的容器卷将测试的web服务test发布"></a>7. 结合前述的容器卷将测试的web服务test发布</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /mydocker/tomcat9/test</span><br><span class="line">mkdir WEB-INF  </span><br></pre></td></tr></table></figure>

<p>在test目录下创建a.jsp文件，在WEB-INF下创建web.xml文件</p>
<p>web.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>a.jsp：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    -----------welcome------------</span><br><span class="line">    &lt;%=&quot;i am in docker tomcat self &quot;%&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &lt;% System.out.println(&quot;=============docker tomcat self&quot;);%&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>宿主机创建的文件已经同步过去了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638357904149-61440767-ec7e-4d2f-98e5-52f6283ad049.png" alt="img"></p>
<p>重启一下容器：<code>docker restart myt9</code>，访问我们刚才发布的test</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638358027262-c2776092-7632-40f8-9486-2a698fe1ae60.png" alt="img"></p>
<h3 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6 总结"></a>7.6 总结</h3><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638358194475-8fae9e61-e779-4b62-a12a-432c276b9466.png" alt="img"></p>
<h2 id="八、Docker常用安装"><a href="#八、Docker常用安装" class="headerlink" title="八、Docker常用安装"></a>八、Docker常用安装</h2><h3 id="8-1-总体步骤"><a href="#8-1-总体步骤" class="headerlink" title="8.1 总体步骤"></a>8.1 总体步骤</h3><p>搜索镜像-&gt;拉取镜像-&gt;查看镜像-&gt;启动镜像-&gt;停止容器-&gt;移除容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search xxx` -&gt; `docker pull xxx:TAG` -&gt; `docker images xxx` -&gt; `docker run [-itd -p port:port] [--name yyy] xxx:TAG` -&gt; `docker stop 容器ID/yyy` -&gt; `docker rm [-f] yyy</span><br></pre></td></tr></table></figure>

<h3 id="8-2-安装mysql"><a href="#8-2-安装mysql" class="headerlink" title="8.2 安装mysql"></a>8.2 安装mysql</h3><h4 id="mysql5-7"><a href="#mysql5-7" class="headerlink" title="mysql5.7"></a>mysql5.7</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=10086 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>-p 12345:3306：将主机的3306端口映射到docker容器的3306端口。</p>
<p>–name mysql：运行服务名字</p>
<p>-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql ：将主机&#x2F;mydata&#x2F;mysql&#x2F;conf目录，挂载到容器的&#x2F;etc&#x2F;mysql目录</p>
<p>-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql：将主机的&#x2F;mydata&#x2F;mysql&#x2F;data目录，挂载到容器的&#x2F;var&#x2F;lib&#x2F;mysql目录</p>
<p>-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql：将主机的&#x2F;mydata&#x2F;mysql&#x2F;log目录，挂载到容器的&#x2F;var&#x2F;log&#x2F;mysql目录</p>
<p>-e MYSQL_ROOT_PASSWORD&#x3D;10086：初始化 root 用户的密码。</p>
<p>-d mysql:5.7 : 后台程序运行mysql5.7</p>
<p>使用windows上的sqlyog进行远程连接：</p>
<p>记得关闭宿主机防火墙或者开启3306端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙信息，看哪些端口可以访问</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者开启3306端口访问（推荐）</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=3306/tcp</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638456614470-3fdeeed3-c09b-4f91-ab48-ad906e106adf.png" alt="img"></p>
<h4 id="mysql8"><a href="#mysql8" class="headerlink" title="mysql8"></a>mysql8</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8.0.22</span><br><span class="line"></span><br><span class="line">docker run -p 3333:3306 --name mysql8 \</span><br><span class="line">-v /mydata/mysql8/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql8/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql8/conf:/etc/mysql \</span><br><span class="line">-v /mydata/mysql8/mysql-files:/var/lib/mysql-files \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=10086 \</span><br><span class="line">-d mysql:8.0.22</span><br></pre></td></tr></table></figure>

<p>mysql8 需要多加一个<code>-v /mydata/mysql8/mysql-files:/var/lib/mysql-files</code> 不然启动报错。我们尝试使用windows上的sqlyog远程连接docker启动的mysql8容器，发现报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638456847352-cf34e758-fd52-448c-bead-723e5ff170a5.png" alt="img"></p>
<p>这是因为mysql8默认使用caching_sha2_password加密方式，而sqlyog不支持，所以需要修改加密规则为mysql_native_password</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过/bin/bash 进入mysql8容器</span></span><br><span class="line">docker exec -it mysql8 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登陆数据库</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>随后我们需要查看是否有不受ip限制的用户，以及修改加密方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 切换到mysql数据库</span><br><span class="line">use mysql</span><br><span class="line"></span><br><span class="line"># 查看<span class="keyword">user</span>表中的用户和host信息</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>, host <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638500559346-3608511d-01fd-4333-9827-ac6af6ea4119.png" alt="img"></p>
<p>可以看到，root已经有一个%，现在修改root@%的加密规则（如果你想新建一个不受访问ip限制的用户也可以mysql高级篇有详细记录：<a target="_blank" rel="noopener" href="https://www.yuque.com/mrlinxi/pxvr4g/rigw3d#hKp7S">远程访问授权</a>)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 修改<span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户的密码规则和密码</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;10086&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 设置密码永不过期</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;10086&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"></span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再次测试远程连接：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22423156/1638500835658-c77b71e1-32af-488e-9820-284cd73cc9a1.png" alt="img"> 连接成功！</p>
<h4 id="使用docker对mysql容器中的数据进行备份"><a href="#使用docker对mysql容器中的数据进行备份" class="headerlink" title="使用docker对mysql容器中的数据进行备份"></a>使用docker对mysql容器中的数据进行备份</h4><p>将docker mysql容器中的所有数据库导出到宿主机的&#x2F;mydata&#x2F;mysql8&#x2F;all-databases.sql文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec myql服务容器ID sh -c &#x27; exec mysqldump --all-databases -uroot -p&quot;10086&quot; &#x27; &gt; /mydata/mysql8/all-databases.sql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果使用UTF-16编码 用--result-file= 替换&gt;</span></span><br><span class="line">docker exec myql服务容器ID sh -c &#x27; exec mysqldump --all-databases -uroot -p&quot;10086&quot; &#x27; --result-file=/mydata/mysql8/all-databases.sql</span><br></pre></td></tr></table></figure>

<p>mysqldump是mysql自带的逻辑备份工具。命令格式：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html">官网mysqldump</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump [选项] 数据库名 [表名] &gt; /路径/filename.sql</span><br><span class="line">mysqldump [选项] --数据库名 [选项 表名] &gt; /路径/filename.sql</span><br><span class="line">mysqldump [选项] --all-databases [选项] &gt; /路径/filename.sql</span><br></pre></td></tr></table></figure>

<p>常用选项说明：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–host</td>
<td>-h</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>–port</td>
<td>-P</td>
<td>服务器端口号</td>
</tr>
<tr>
<td>–user</td>
<td>-u</td>
<td>mysql用户名</td>
</tr>
<tr>
<td>–password</td>
<td>-p</td>
<td>mysql密码</td>
</tr>
<tr>
<td>–database</td>
<td></td>
<td>指定要备份的数据库</td>
</tr>
<tr>
<td>–all-databases</td>
<td></td>
<td>备份mysql上的所有数据库</td>
</tr>
<tr>
<td>–compact</td>
<td></td>
<td>压缩模式，产生更少的输出</td>
</tr>
<tr>
<td>–comments</td>
<td></td>
<td>添加注释信息</td>
</tr>
</tbody></table>
<h3 id="8-3-安装redis"><a href="#8-3-安装redis" class="headerlink" title="8.3 安装redis"></a>8.3 安装redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line"></span><br><span class="line">docker run -p 6379:6379 -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>

<p>–appendonly yes 表示使用AOF进行持久化 （redis默认使用rdb进行持久化）</p>
<p>redis.conf是个文件夹，不是个文件 (小声BB：这个redis.conf文件夹是不是太容易引起歧义了？还有redis-server启动的时候，后面跟的那串不是指定的配置文件的路径吗，讲道理redis.conf应该就是个配置文件才对)；</p>
<p>在主机&#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf目录下新建redis.conf文件</p>
<p><code>vim /mydata/redis/conf/redis.conf</code>  <a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2021/txt/22423156/1638542972834-f404cbca-6492-4a41-adcd-b6ff934282d3.txt">📎redis.conf.txt</a></p>
<p>测试redis-cli连接：<code>docker exec -it redis容器ID redis-cli</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638543060470-c9d2ae73-1dcf-40d9-8e07-c0f758b27352.png" alt="img"></p>
<p>测试生成持久化文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638543142322-5e0e0c2d-e57d-4801-b432-bf22bf018a99.png" alt="img"></p>
<h2 id="九、本地镜像发布到阿里云"><a href="#九、本地镜像发布到阿里云" class="headerlink" title="九、本地镜像发布到阿里云"></a>九、本地镜像发布到阿里云</h2><p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638543174016-789c3bbe-217b-49d8-a3bf-7be236507bcc.png" alt="img"></p>
<h3 id="8-1-镜像的生成方法"><a href="#8-1-镜像的生成方法" class="headerlink" title="8.1 镜像的生成方法"></a>8.1 镜像的生成方法</h3><ul>
<li><p>前面讲过的DockerFile</p>
</li>
<li><p>从容器创建一个新的镜像：<code>docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</code></p>
</li>
<li><ul>
<li>OPTIONS选项说明：-a：提交的镜像作者、-m：提交时的说明文字</li>
</ul>
</li>
</ul>
<p>我们之前自己做了一个包含vim和ifconfig的centos——mycentos:0.1，现在我们把它更新到0.2，并生成一个0.2的镜像。</p>
<p>先看看mycentos:0.1有没有容器<code>docker ps -a</code>，没有就创建一个容器，<code>docker run -itd mycentos:0.1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -a mrlinxi -m &quot;new contos 0.2 from 0.1&quot; 容器ID mycentos:0.2</span><br></pre></td></tr></table></figure>

<p>这样就得到了mycentos:0.2的镜像</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638579150604-5e5e175b-d5de-4522-9a56-ff3e68d41028.png" alt="img"></p>
<h3 id="9-2-将本地镜像推送到阿里云"><a href="#9-2-将本地镜像推送到阿里云" class="headerlink" title="9.2 将本地镜像推送到阿里云"></a>9.2 将本地镜像推送到阿里云</h3><p>登陆阿里云，进入控制台</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22423156/1638579895193-548577ed-ca9a-42f2-a6fc-f9c04f6d4691.png" alt="img"></p>
<p>左上角菜单，点开搜索容器镜像服务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638579944641-1dc91178-ba82-429f-8595-865c7455e682.png" alt="img"></p>
<p>实例列表—&gt;个人&#x2F;企业(要钱) 没有的需要创建一下，创建需要设置一个repository密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638580071904-e7a62348-3712-4a7d-bc0e-bcebcc8f4304.png" alt="img"></p>
<p>然后创建一个镜像仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638580295659-6237e091-42d6-4894-a24e-2c41785ee3a4.png" alt="img"></p>
<p>然后下一步，选择本地仓库创建：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638580339243-c4662f2d-9894-419a-926c-d09d413d7f44.png" alt="img"></p>
<p>创建好仓库后，会有相应的操作指南：</p>
<p>aliyun给的操作指南:</p>
<h4 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=兴趣使然的小小 registry.cn-chengdu.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>您可以在访问凭证页面修改凭证密码。</p>
<h4 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull registry.cn-chengdu.aliyuncs.com/mrilinxi/mycentos:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h4 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=兴趣使然的小小 registry.cn-chengdu.aliyuncs.com$ docker tag [ImageId] registry.cn-chengdu.aliyuncs.com/mrilinxi/mycentos:[镜像版本号]$ docker push registry.cn-chengdu.aliyuncs.com/mrilinxi/mycentos:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<h4 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h4><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p>
<p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-chengdu.aliyuncs.com 作为Registry的域名登录。</p>
<h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-chengdu.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>

<p>使用 “docker push” 命令将该镜像推送至远程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker push registry-vpc.cn-chengdu.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>







<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638580567240-fcf9ded7-0175-4bb3-8205-0cfb9e359538.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登陆仓库 首次登陆需要输入之前我们设置的仓库密码</span></span><br><span class="line">docker login --username=阿里云账户 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/mrlinxi/mycentos:[镜像版本号]</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/mrlinxi/mycentos:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638580765715-1f3cb6d4-173b-446e-bab4-b1a9b28731e1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638581159286-1ad8f8a9-b24a-44b2-8a05-9ee291206f5d.png" alt="img"></p>
<p>提交后，本地也会有一份提交的镜像。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638600211757-8aec55a4-687f-497e-ae7d-811c7b639412.png" alt="img"></p>
<p>我们尝试从阿里云拉取我们刚才push的镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地提交的镜像</span></span><br><span class="line">docker rmi -f registry.cn-hangzhou.aliyuncs.com/mrlinxi/mycentos:0.2.1</span><br><span class="line"></span><br><span class="line">dokcer pull registry.cn-hangzhou.aliyuncs.com/mrlinxi/mycentos:0.2.1</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ladidol/figurebed@main/img/1638600388706-ddeb4535-dc1e-4dcc-9d5b-24193a91e127.png" alt="img"></p>
<h2 id="十、Docker-Compose"><a href="#十、Docker-Compose" class="headerlink" title="十、Docker Compose"></a>十、Docker Compose</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Compose</code>项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。从功能上看，跟<code>OpenStack</code>中的<code>Heat</code>十分相似。</p>
<p><code>Compose</code>定位是[定义和运行多个<code>Dockerfile</code>模板文件]，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要更多应用容器来相互配合完成某个项目的情况。例如要实现一个Web项目，除了Web服务器本身，往往还需要再加上后端的数据服务容器，甚至还需要负载容器等。</p>
<p><code>Compose</code>恰好满足了这样的需求。它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件(YAML格式)来定义一组相关联的应用容器为一个项目</p>
<p><code>Compose</code>中有两个重要的概念：</p>
<ul>
<li>服务(<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像实例。</li>
<li>项目(<code>project</code>)：由一组关联的应用容器组成的完整业务单元，在<code>docker-compose.yml</code>文件中定义。</li>
</ul>
<p><code>Compose</code>的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷的生命周期管理</p>
<p><code>Compose</code>项目由Python编写，实现上调用了Docker服务器提供的API来对容器进行管理。因此，只要所操纵的平台支持Docker API，就可以在其上利用<code>Compose</code>来进行编排项目</p>
<h4 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker-Compose安装"></a>Docker-Compose安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64 &gt; /usr/local/bin/docker-compose <span class="comment">#下载docker-compose</span></span><br><span class="line">docker-compose --version <span class="comment">#查看docker-compose是否安装成功复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h4 id="Docker-Compose的入门"><a href="#Docker-Compose的入门" class="headerlink" title="Docker-Compose的入门"></a>Docker-Compose的入门</h4><ol>
<li><p>创建一个docker-compose.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> docker-compose.yml复制复制失败复制成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中定义一个项目中存在哪些服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">webapp:</span>  <span class="comment">#服务名全局唯一</span></span><br><span class="line">        <span class="attr">image:</span> <span class="comment">#镜像名:tag</span></span><br><span class="line">        <span class="attr">ports:</span>  <span class="comment">#端口映射</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">            <span class="string">复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>3.通过docker-compose运行一组容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up    <span class="comment">#前台运行</span></span><br><span class="line">docker-compose up -d   <span class="comment">#后台运行复制复制失败复制成功</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Docker-Compose命令模板指令"><a href="#Docker-Compose命令模板指令" class="headerlink" title="Docker-Compose命令模板指令"></a>Docker-Compose命令模板指令</h4><p>模板文件默认是使用<code>Compose</code>的核心，涉及到的指令关键字也比较多，默认的模板文件名称为<code>docker-compose.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">webapp:</span>  <span class="comment">#服务名全局唯一</span></span><br><span class="line">        <span class="attr">image:</span> <span class="comment">#镜像名:tag</span></span><br><span class="line">        <span class="attr">ports:</span>  <span class="comment">#端口映射(建议引号括起来)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>注意每个服务都必须通过<code>image</code>指令指定镜像或<code>build</code>指令（需要Dockerfile）等来自动构建生成镜像</p>
<p>如果使用<code>build</code>指令，在Dockerfile中设置的选项（例如：<code>CMD</code>,<code>EXPOSE</code>,<code>VOLUME</code>,<code>ENV</code>等）将会自动被获取，无需在<code>docker-compose.yml</code>中重复设置。</p>
<h5 id="imgae"><a href="#imgae" class="headerlink" title="imgae"></a>imgae</h5><p>指定为镜像名称或镜像ID。如果镜像本地不存在，<code>Compose</code>将会尝试手动拉起这个镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span>        <span class="comment">#默认为最新版本</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">镜像名:版本号</span>    </span><br><span class="line"><span class="attr">image:</span> <span class="string">摘要复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h5><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口（HOST：CONTAINER）格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span><span class="string">:&quot;8001&quot;复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>主要：当使用<code>HOST:CONTAINER</code>格式来映射端口时，如你使用的容器端口小于60并且没有放到引号里面，可能会得到错误的结果，因为<code>YAML</code>会自动解析xx:yy这种数字格式为60进制，为避免出现这种问题，建议采用引号包括起来的字符串格式</p>
<h5 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h5><p>数据卷所挂载路径设置，可以设置为宿主机路径(<code>HOST</code>:<code>CONTAINER</code>)或者数据卷的名称(<code>VOLUME</code>:<code>CONTAINER</code>)，并且可以设置访问模式(<code>HOST</code>:<code>CONTAINER:ro</code>)。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">tomcat:</span></span><br><span class="line">        <span class="attr">tomcat:</span> <span class="string">tomcat:8.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">        <span class="attr">voulumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">tomcatwebapps:/usr/local/tomcat/webapps</span></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#声明上面容器使用的卷名</span></span><br><span class="line">    <span class="attr">tomcatwebapps:</span> <span class="comment">#使用的卷名</span></span><br><span class="line">        <span class="attr">external:</span>  <span class="comment">#使用自定义的卷名 </span></span><br><span class="line">            <span class="literal">true</span>    <span class="comment">#true确定使用指定卷名    注意：一旦使用外部自定义卷名，需要手动创建数据卷复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h5><p>配置容器连接的网络</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">tomcat01:</span></span><br><span class="line">        <span class="attr">tomcat:</span> <span class="string">tomcat:8.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">        <span class="attr">voulumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">tomcatwebapps01:/usr/local/tomcat/webapps</span></span><br><span class="line">        <span class="attr">networks:</span>    <span class="comment">#代表当前服务使用哪个网络桥</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">tomcat02:</span></span><br><span class="line">        <span class="attr">tomcat:</span> <span class="string">tomcat:8.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8081:8080&quot;</span></span><br><span class="line">        <span class="attr">voulumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">tomcatwebapps01:/usr/local/tomcat/webapps</span></span><br><span class="line">        <span class="attr">networks:</span>    <span class="comment">#代表当前服务使用哪个网络桥</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#声明上面容器使用的卷名</span></span><br><span class="line">    <span class="attr">tomcatwebapps01:</span> <span class="comment">#使用的卷名</span></span><br><span class="line">        <span class="attr">external:</span>  <span class="comment">#使用自定义的卷名 </span></span><br><span class="line">            <span class="literal">false</span>    <span class="comment">#true确定使用指定卷名    注意：一旦使用外部自定义卷名，需要手动创建数据卷</span></span><br><span class="line">    <span class="attr">tomcatwebapps02:</span></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义服务用到桥</span></span><br><span class="line">    <span class="attr">hello:</span> <span class="comment">#上面服务用到网桥名称，默认为bridge</span></span><br><span class="line">        <span class="attr">external:</span> </span><br><span class="line">            <span class="literal">true</span>    <span class="comment">#使用外部指定网桥    注意：网桥必须存在复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h5><p>指定容器名。默认将会使用<code>项目名称_服务名称_序号</code>这样子的格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：指定容器后，该服务无法进行扩展，因为Docker不允许多个容器具有相同的名称</p>
</blockquote>
<h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h5><p>设置环境变量，你可以使用数组或字典两种格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span> </span><br><span class="line">    <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">    <span class="attr">SESSION_SECRET:</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SESSION_SECRET复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到<code>true</code>|<code>false</code>,<code>yes</code>|<code>no</code>等表达<strong>布尔</strong>含义的词汇，最好放到引号里，避免YAML自动内容为对应的布尔语义</p>
<h5 id="command"><a href="#command" class="headerlink" title="command"></a>command</h5><p>覆盖容器启动后执行的命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span><span class="string">复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h5><p>从文件中获取环境变量，可以单独的文件路径或列表</p>
<p>如果通过<code>docker-compose -f FILE</code>方式来指定Compose模板文件，则<code>env_file</code>中变量的路径会基于模板文件路径</p>
<p>如果有变量名称与<code>environment</code>指令冲突，则按照惯例，以后者为准</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env_file:</span> <span class="string">.env</span></span><br><span class="line"><span class="attr">env_file:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">./common.env</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./apps/web.env</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/opt/secrets.env复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<p>环境变量文件中的每一行必须符合格式，支持<code>#</code>开头的注释行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Common.env: Set development enviroment</span><br><span class="line">PROG_ENV=development复制复制失败复制成功</span><br></pre></td></tr></table></figure>

<h5 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h5><p>解决容器的依赖，启动先后问题。下面的例子中会先启动<code>redis db</code>再启动<code>web</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">web:</span> </span><br><span class="line">        <span class="attr">build:</span> </span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">db</span>    <span class="comment">#服务名</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">redis</span>    <span class="comment">#服务名</span></span><br><span class="line">    <span class="attr">redis:</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">db:</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">postgres复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>web</code>服务不会等待<code>redis db</code>[完全启动]之后才启动</p>
</blockquote>
<h5 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h5><p>通过命令检查容器是否健康运行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span> </span><br><span class="line">    <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>,<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">    <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">retries:</span> <span class="number">3</span><span class="string">复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><a target="_blank" rel="noopener" href="https://docs.hwawy.cn/#/Docker/?id=sysctls">sysctls</a></h5><p>配置容器内核参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">    <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">    <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h5><p>指定容器的ulimits限制数</p>
<p>例如，指定最大进程数为65535，指定文件句柄数位2000(软限制，应用可以随时修改，不能操作限制)和40000（系统硬件限制，只能root用户提高）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">    <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">    <span class="attr">nofile:</span> </span><br><span class="line">        <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">40000</span><span class="string">复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>用来将指定的Dockerfile打包成镜像，然后再运行该镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">        <span class="attr">build:</span>    <span class="comment">#用来指定Dockerfile所在目录，先根据build中的Dockerfile自动构建镜像，自动运行容器</span></span><br><span class="line">            <span class="attr">context:</span> <span class="comment">#指定上下文目录dockerfile所在的目录</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span> <span class="comment">#dockerfile构建文件名字</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">容器名</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8080:9091&quot;</span></span><br><span class="line">        <span class="attr">network:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">tomcat01复制复制失败复制成功</span></span><br></pre></td></tr></table></figure>

<h4 id="Docker-Compose中的常用命令"><a href="#Docker-Compose中的常用命令" class="headerlink" title="Docker-Compose中的常用命令"></a>Docker-Compose中的常用命令</h4><h5 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h5><p>对于<code>Compose</code>来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务和容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会收到命令影响</p>
<p>执行<code>docker-compose [COMMAND] --help</code> 或者<code>docker-compose help [COMMAND]</code>可以查看具体是某个命令的使用格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose [-f=&lt;args&gt;...] [options] [COMMAND] [ARGS...]复制复制失败复制成功</span><br></pre></td></tr></table></figure>

<h5 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h5><ul>
<li><code>-f</code> ,<code>--file FILE</code>指定使用的Compose模板文件，默认为docker-compose.yml，可以多次指定</li>
<li><code>-p</code>,’–project-name NAME’指定项目名称，默认使用所在目录作为项目名</li>
<li><code>--x-networking</code>使用Docker的可插拔网络后端特性</li>
<li><code>--verbose</code>输出更多调试信息</li>
<li><code>-v,--version</code>打印版本并退出</li>
</ul>
<h5 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up</span><br></pre></td></tr></table></figure>

<p>格式为<code>docker-compose up [option] [SERVICE...]</code></p>
<ul>
<li>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并管理服务相关容器的一系列操作</li>
<li>链接的服务都将自动启动，除非已经处于运行状态</li>
<li>大部分时候可以通过该命令来启动一个项目</li>
<li>默认情况，<code>docker-compose up</code>启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便的进行调试</li>
<li>当通过<code>Ctrl -C</code> 停止命令时，所有容器将会停止</li>
<li>如果通过<code>docker-compose up</code>，将会在后台启动并运行所有的容器，一般推荐生产环境下使用该选项</li>
<li>默认情况下，如果服务容器已经存在，<code>docker-compose up</code>将会尝试停止该容器，然后重新创建（保持使用<code>volumes-from</code>挂载的卷），以保证新启动的服务匹配<code>docker-compose.yml</code>文件的最新内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dwon</span><br></pre></td></tr></table></figure>

<ul>
<li>此命令将会停止<code>up</code>命令启动的容器，并移除网络</li>
</ul>
<p><code>exec</code><strong>只能通过服务ID进入</strong></p>
<ul>
<li>进入指定容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为<code>docker-compose ps [options][SERVICE...]</code></li>
<li>列出选项中目前的所有容器</li>
<li>选项<ul>
<li><code>-q</code> 只打印容器的ID信息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restart</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为<code>docker-compose rm [OPTION][SERVICE]</code></li>
<li>重启项目中的服务</li>
<li>选项：<ul>
<li><code>-t,--timeout TIMEOUT</code>指定重启前停止容器的操作（默认为10秒）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为<code>docker-compose rm [OPTION][SERVICE]</code></li>
<li>删除所有（停止状态）服务容器，推荐先执行<code>docker-compose stop</code>来停止容器</li>
<li>选项：<ul>
<li><code>-f,--force</code>强制直接删除，包括非停止状态的容器，一般尽量不要使用该选项</li>
<li><code>-v</code>删除容器所挂在的数据卷</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statr</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为<code>docker-compose start [SERVICE...]</code></li>
<li>启动已经存在的服务容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为<code>docker-compose stop [options][SERVICE...]</code></li>
<li>停止已经处于运行状态的容器，但不删除它。通过<code>docker-compose start</code>可以再次启动这些容器</li>
<li>选项：<ul>
<li><code>-t,--timeout TIMEOUT</code>停止容器时候的超时（默认为10秒）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<ul>
<li>查看各个服务容器内运行的进度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unpause</span><br></pre></td></tr></table></figure>

<ul>
<li>格式为docker-compose unpause [SEVICE..]</li>
<li>恢复处于暂停状态的容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logs</span><br></pre></td></tr></table></figure>

<ul>
<li>查看服务日志</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/mrlinxi/pxvr4g/polyyw#fV3l8">借鉴链接1</a><br><a target="_blank" rel="noopener" href="https://docs.hwawy.cn/#/Docker/">借鉴链接2</a></p>
<h2 id="还需要把compose个看完-推荐链接传送门"><a href="#还需要把compose个看完-推荐链接传送门" class="headerlink" title="还需要把compose个看完,推荐链接传送门"></a>还需要把compose个看完,推荐链接<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gr4y1U7CY?spm_id_from=333.337.search-card.all.click">传送门</a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ladidol</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ladfeng.top/2022/03/21/Docker%E5%85%A5%E9%97%A8/">http://ladfeng.top/2022/03/21/Docker%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ladfeng.top" target="_blank">小小的博客乐园</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8/">入门</a></div><div class="post_share"><div class="social-share" data-image="https://qiniu.ladidol.top/img/wallhaven-z8m6gj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/22/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="https://qiniu.ladidol.top/img/77126af1e50862120c1f9b021bf44195.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">英语语法框架学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/21/restful/"><img class="next-cover" src="https://qiniu.ladidol.top/img/t01dc7052c759f96390.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">restful接口设计规范</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/04/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5Dgolang%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6/" title="(未完成)golang语法进阶"><img class="cover" src="https://qiniu.ladidol.top/img/e31c72cb7088cfcf719bc24574155065.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-04</div><div class="title">(未完成)golang语法进阶</div></div></a></div><div><a href="/2022/03/31/golang%E5%85%A5%E9%97%A8/" title="golang入门"><img class="cover" src="https://qiniu.ladidol.top/img/wallhaven-4xzwyo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">golang入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://qiniu.ladidol.top/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ladidol</div><div class="author-info__description">这是一个小小小枸杞</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ladidol"><i class="fab fa-github"></i><span>Follow On Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站主要用于学习和分享,和自娱自乐罢了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">Docker 一篇入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Docker-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">一、Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1、基本概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Docker-%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">二、Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">1、环境检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">4.2.</span> <span class="toc-text">2、基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.4.</span> <span class="toc-text">3、安装步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8Chello-world"><span class="toc-number">4.5.</span> <span class="toc-text">4.测试运行hello-world</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Docker-%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">三、Docker 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">5.1.</span> <span class="toc-text">docker是怎么工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E6%AF%94VM%E5%BF%AB"><span class="toc-number">5.2.</span> <span class="toc-text">为什么Docker比VM快</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">四、Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">4.1帮助启动类命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 镜像命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.3.</span> <span class="toc-text">4.3容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%EF%BC%8C%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">1下载镜像，新建并启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">2列出当前所有正在运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text">3退出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%EF%BC%88start-%E4%B8%8E-run%E5%8C%BA%E5%88%86%E5%BC%80%EF%BC%89-amp-%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%88restart%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">4启动容器（start 与 run区分开） &amp; 重启容器（restart）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%9B%9E%E5%88%B0%E5%B7%B2%E7%BB%8F%E9%80%80%E5%87%BA%E7%9A%84%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.5.</span> <span class="toc-text">5回到已经退出的但是仍然在运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-amp-%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.6.</span> <span class="toc-text">6停止容器 &amp; 强制停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.7.</span> <span class="toc-text">7删除已停止的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E9%87%8D%E8%A6%81%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.3.8.</span> <span class="toc-text">8重要容器命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">4.3总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Dockers%E9%95%9C%E5%83%8F"><span class="toc-number">7.</span> <span class="toc-text">五、Dockers镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88-amp-%E9%95%9C%E5%83%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">5.1 镜像是什么 &amp; 镜像的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85"><span class="toc-number">7.2.</span> <span class="toc-text">5.2 Docker镜像commit操作补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">8.</span> <span class="toc-text">六、Docker容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%AE%80%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">6.1 容器数据卷简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%A1%88%E4%BE%8B"><span class="toc-number">8.2.</span> <span class="toc-text">6.2 容器数据卷案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0"><span class="toc-number">8.2.1.</span> <span class="toc-text">命令添加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">6.3 数据卷容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-DockerFile%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">七. DockerFile解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-DockerFile%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">7.1 DockerFile简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-DockerFile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">9.2.</span> <span class="toc-text">7.2 DockerFile构建过程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-DockerFile%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-number">9.3.</span> <span class="toc-text">7.3 DockerFile体系结构(保留字指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.</span> <span class="toc-text">7.4 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Base%E9%95%9C%E5%83%8F-scratch"><span class="toc-number">9.4.1.</span> <span class="toc-text">1. Base镜像(scratch)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8Fmycentos"><span class="toc-number">9.4.2.</span> <span class="toc-text">2. 自定义镜像mycentos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F%E2%80%94%E2%80%94docker-run"><span class="toc-number">9.4.3.</span> <span class="toc-text">③ 运行自定义镜像——docker run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2"><span class="toc-number">9.4.4.</span> <span class="toc-text">④ 列出镜像的变更历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CMD-x2F-ENTRYPOINT-%E9%95%9C%E5%83%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.5.</span> <span class="toc-text">3. CMD&#x2F;ENTRYPOINT 镜像案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-CMD%E9%95%9C%E5%83%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.5.1.</span> <span class="toc-text">① CMD镜像案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-ENTRYPOINT%E9%95%9C%E5%83%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.5.2.</span> <span class="toc-text">② ENTRYPOINT镜像案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-ONBUILD%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.5.3.</span> <span class="toc-text">③ ONBUILD案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8FTomcat9"><span class="toc-number">9.5.</span> <span class="toc-text">7.5 自定义镜像Tomcat9</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">1. 创建目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%86jdk%E5%92%8Ctomcat%E5%AE%89%E8%A3%85%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%8B%B7%E8%B4%9D%E8%BF%9B%E4%B8%8A%E8%BF%B0%E7%9B%AE%E5%BD%95"><span class="toc-number">9.5.2.</span> <span class="toc-text">2. 将jdk和tomcat安装的压缩包拷贝进上述目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8tomcat9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BADockerfile%E6%96%87%E4%BB%B6"><span class="toc-number">9.5.3.</span> <span class="toc-text">3. 在tomcat9目录下新建Dockerfile文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%EF%BC%9Adocker-build-t-mrlinxitomcat9"><span class="toc-number">9.5.4.</span> <span class="toc-text">4. 构建镜像：docker build -t mrlinxitomcat9 .</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">9.5.5.</span> <span class="toc-text">5. 创建容器并启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.6.</span> <span class="toc-text">6. 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%93%E5%90%88%E5%89%8D%E8%BF%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%B0%86%E6%B5%8B%E8%AF%95%E7%9A%84web%E6%9C%8D%E5%8A%A1test%E5%8F%91%E5%B8%83"><span class="toc-number">9.5.7.</span> <span class="toc-text">7. 结合前述的容器卷将测试的web服务test发布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%80%BB%E7%BB%93"><span class="toc-number">9.6.</span> <span class="toc-text">7.6 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85"><span class="toc-number">10.</span> <span class="toc-text">八、Docker常用安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.</span> <span class="toc-text">8.1 总体步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AE%89%E8%A3%85mysql"><span class="toc-number">10.2.</span> <span class="toc-text">8.2 安装mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql5-7"><span class="toc-number">10.2.1.</span> <span class="toc-text">mysql5.7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql8"><span class="toc-number">10.2.2.</span> <span class="toc-text">mysql8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8docker%E5%AF%B9mysql%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD"><span class="toc-number">10.2.3.</span> <span class="toc-text">使用docker对mysql容器中的数据进行备份</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%AE%89%E8%A3%85redis"><span class="toc-number">10.3.</span> <span class="toc-text">8.3 安装redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">11.</span> <span class="toc-text">九、本地镜像发布到阿里云</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%95%9C%E5%83%8F%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">8.1 镜像的生成方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">11.2.</span> <span class="toc-text">9.2 将本地镜像推送到阿里云</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91Docker-Registry"><span class="toc-number">11.2.1.</span> <span class="toc-text">1. 登录阿里云Docker Registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8ERegistry%E4%B8%AD%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">11.2.2.</span> <span class="toc-text">2. 从Registry中拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%86%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0Registry"><span class="toc-number">11.2.3.</span> <span class="toc-text">3. 将镜像推送到Registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-number">11.2.4.</span> <span class="toc-text">4. 选择合适的镜像仓库地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.2.5.</span> <span class="toc-text">5. 示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Docker-Compose"><span class="toc-number">12.</span> <span class="toc-text">十、Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">12.0.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose%E5%AE%89%E8%A3%85"><span class="toc-number">12.0.2.</span> <span class="toc-text">Docker-Compose安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose%E7%9A%84%E5%85%A5%E9%97%A8"><span class="toc-number">12.0.3.</span> <span class="toc-text">Docker-Compose的入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose%E5%91%BD%E4%BB%A4%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4"><span class="toc-number">12.0.4.</span> <span class="toc-text">Docker-Compose命令模板指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#imgae"><span class="toc-number">12.0.4.1.</span> <span class="toc-text">imgae</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ports"><span class="toc-number">12.0.4.2.</span> <span class="toc-text">ports</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#volumes"><span class="toc-number">12.0.4.3.</span> <span class="toc-text">volumes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#networks"><span class="toc-number">12.0.4.4.</span> <span class="toc-text">networks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#container-name"><span class="toc-number">12.0.4.5.</span> <span class="toc-text">container_name</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#environment"><span class="toc-number">12.0.4.6.</span> <span class="toc-text">environment</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#command"><span class="toc-number">12.0.4.7.</span> <span class="toc-text">command</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#env-file"><span class="toc-number">12.0.4.8.</span> <span class="toc-text">env_file</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#depends-on"><span class="toc-number">12.0.4.9.</span> <span class="toc-text">depends_on</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#healthcheck"><span class="toc-number">12.0.4.10.</span> <span class="toc-text">healthcheck</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysctls"><span class="toc-number">12.0.4.11.</span> <span class="toc-text">sysctls</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulimits"><span class="toc-number">12.0.4.12.</span> <span class="toc-text">ulimits</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#build"><span class="toc-number">12.0.4.13.</span> <span class="toc-text">build</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">12.0.5.</span> <span class="toc-text">Docker-Compose中的常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.0.5.1.</span> <span class="toc-text">命令对象与格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">12.0.5.2.</span> <span class="toc-text">命令选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">12.0.5.3.</span> <span class="toc-text">命令使用说明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%98%E9%9C%80%E8%A6%81%E6%8A%8Acompose%E4%B8%AA%E7%9C%8B%E5%AE%8C-%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5%E4%BC%A0%E9%80%81%E9%97%A8"><span class="toc-number">13.</span> <span class="toc-text">还需要把compose个看完,推荐链接传送门</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/17/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5Dj2ee%E4%B8%8A%E6%9C%BA%E4%BB%BB%E5%8A%A1%E6%B1%87%E6%80%BB/" title="j2ee上机任务汇总"><img src="https://qiniu.ladidol.top/img/72c7a71c88a895e846c2510c73b31215d9ddff05_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="j2ee上机任务汇总"/></a><div class="content"><a class="title" href="/2022/04/17/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5Dj2ee%E4%B8%8A%E6%9C%BA%E4%BB%BB%E5%8A%A1%E6%B1%87%E6%80%BB/" title="j2ee上机任务汇总">j2ee上机任务汇总</a><time datetime="2022-04-17T13:13:35.000Z" title="发表于 2022-04-17 21:13:35">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/17/%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="后端解决跨域问题"><img src="https://qiniu.ladidol.top/img/79aa649212e59871b2e87f6a20e4c02ccd04a80b_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="后端解决跨域问题"/></a><div class="content"><a class="title" href="/2022/04/17/%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="后端解决跨域问题">后端解决跨域问题</a><time datetime="2022-04-17T13:13:35.000Z" title="发表于 2022-04-17 21:13:35">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/" title="后端解决跨域问题"><img src="https://qiniu.ladidol.top/img/79aa649212e59871b2e87f6a20e4c02ccd04a80b_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="后端解决跨域问题"/></a><div class="content"><a class="title" href="/2022/04/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/" title="后端解决跨域问题">后端解决跨域问题</a><time datetime="2022-04-17T13:13:35.000Z" title="发表于 2022-04-17 21:13:35">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/17/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5Dmaven/" title="maven"><img src="https://qiniu.ladidol.top/img/760a404930ebb4608f6b18811ab1052357a9d3c3_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="maven"/></a><div class="content"><a class="title" href="/2022/04/17/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5Dmaven/" title="maven">maven</a><time datetime="2022-04-17T11:41:55.000Z" title="发表于 2022-04-17 19:41:55">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5DSpringBootWeb%E5%BC%80%E5%8F%91%E6%8F%90%E5%8D%87(Swagger)/" title="(未完成)SpringBootWeb开发提升(Swagger)"><img src="https://qiniu.ladidol.top/img/ed6a8ccc3bbfdc5ca603d116e89224bc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(未完成)SpringBootWeb开发提升(Swagger)"/></a><div class="content"><a class="title" href="/2022/04/16/%5B%E6%9C%AA%E5%AE%8C%E6%88%90%5DSpringBootWeb%E5%BC%80%E5%8F%91%E6%8F%90%E5%8D%87(Swagger)/" title="(未完成)SpringBootWeb开发提升(Swagger)">(未完成)SpringBootWeb开发提升(Swagger)</a><time datetime="2022-04-16T09:50:15.000Z" title="发表于 2022-04-16 17:50:15">2022-04-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ladidol</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'yCA2jFnRuIUXINItIXDuuGgx-9Nh9j0Va',
      appKey: 'u4C7GUNrW6Lqmqe1axkRqKTt',
      avatar: 'wavatar',
      serverURLs: '',
      enableQQ: true,
      placeholder: 'hi，如果要评论的话，请一定写上自己的基本信息，不然身份都是匿名者！评论支持Markdown语法，暂时只能使用随机头像。',
      pageSize: '10',
      master: '9f8e9371a0cbeaa8737f5f1baa1d0f10',
      tagMeta: ["博主","小伙伴","访客"],
      visitor: 'true',
      //md5jiami.51240.com ,md5加密推荐这个网站
      friends: ["8f5657bb65c4fb1e2621401dd5003f5b","c94e74ad7b2afcda9e661919adb66076",
      "56e41b3fa26fbd1f720a2cd3fd9423fb","f690c9dffa8c8b592fe45e8750712b24"],
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script type="text/javascript" src="/js/fairyDustCursor.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="/%5Bobject%20Object%5D" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>